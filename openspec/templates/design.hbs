{{!-- Phase 2 Step 5: Design Split (design.md) --}}

# Role
You are the Tech Lead.

# Goal
Design the Implementation Architecture (Step 5) based on `spec.md`.

# Development Mode Selection
Before designing, determine the development mode for this feature:
- **fullstack**: Complete frontend + backend + middleware (default)
- **frontend-only**: Frontend development with mock backend
- **backend-only**: Backend API development without frontend
- **middleware-only**: Middleware/infrastructure development

**Selected Mode**: {{ dev_mode | default: "fullstack" }}

# Tech Stack Constraints (from Context)
- Backend: (defined in context/tech_stack.md)
- Frontend: (defined in context/tech_stack.md)
- Infrastructure: (defined in infrastructure.md)

# Output Sections

## 0. Development Mode Configuration

### Mode: {{ dev_mode | default: "fullstack" }}

{{#if (eq dev_mode "frontend-only")}}
**Frontend-Only Mode**:
- Mock backend using JSON examples from `spec.md`
- Mock server configuration (e.g., MSW, json-server)
- No backend implementation required in this phase
- Focus: UI components, state management, user interactions
{{/if}}

{{#if (eq dev_mode "backend-only")}}
**Backend-Only Mode**:
- API implementation without frontend
- Testing via Postman/curl/automated tests
- CORS configuration for future frontend integration
- Focus: API endpoints, business logic, database operations
{{/if}}

{{#if (eq dev_mode "middleware-only")}}
**Middleware-Only Mode**:
- Isolated middleware development and testing
- Mock handlers for testing middleware behavior
- Focus: Authentication, validation, logging, error handling
{{/if}}

{{#if (eq dev_mode "fullstack")}}
**Fullstack Mode**:
- Complete frontend + backend + middleware integration
- E2E testing with real API calls
- Contract verification between frontend and backend
- Focus: End-to-end feature implementation
{{/if}}

---

## 1. Frontend Architecture

{{#unless (eq dev_mode "backend-only")}}
### 1.1 Component Tree
List new components needed:
- **Component Name**: Description
- **Component Name**: Description

### 1.2 State Management
- How to handle the `StandardResp` data wrapper?
- Which state management solution? (Context API, Redux, Zustand, etc.)
- How to handle loading/error states?

### 1.3 Mocking Strategy (for frontend-only or fullstack modes)
{{#if (eq dev_mode "frontend-only")}}
**Mock Server Setup**:
- Tool: (e.g., MSW, json-server, Mirage JS)
- Mock data source: JSON examples from `spec.md`
- Mock server port: 3001 (or configured port)
- How to simulate error responses?
{{else}}
- How to use the JSON examples from Contract for Step 6?
- Mock data location: (e.g., `src/mocks/`)
{{/if}}

### 1.4 API Integration
- API client library: (e.g., axios, fetch, React Query)
- Base URL configuration
- Request interceptors (add X-Request-ID, auth token)
- Response interceptors (handle StandardResp, errors)
- Error handling strategy

### 1.5 Routing (if applicable)
- New routes needed
- Route guards/protection
- Navigation flow
{{else}}
**Frontend Architecture**: Not applicable for backend-only mode.
{{/unless}}

---

## 2. Backend Architecture

{{#unless (eq dev_mode "frontend-only")}}
### 2.1 Router Location
- Which file in routers/? (e.g., `routers/users.py`, `routers/orders.ts`)
- New endpoints to add
- HTTP methods and paths

### 2.2 Business Logic
- Define the class in business layer (e.g., `business/UserService.py`)
- Key methods and their responsibilities
- Input validation logic
- Business rule enforcement

### 2.3 DB Operations
- Database tables involved (from `spec.md`)
- Query patterns (SELECT, INSERT, UPDATE, DELETE)
- Transaction requirements
- Locking strategy (if needed): Optimistic vs Pessimistic
- Index usage for performance

### 2.4 Middleware Integration
- Authentication: Required for which endpoints?
- Validation: Request schema validation
- Logging: What to log? (refer to `infrastructure.md`)
- Error handling: Custom error codes (refer to `infrastructure.md`)

### 2.5 External Dependencies
- Third-party APIs or services
- Caching strategy (if applicable)
- Rate limiting considerations
{{else}}
**Backend Architecture**: Not applicable for frontend-only mode.
{{/unless}}

---

## 3. Middleware Architecture

{{#if (eq dev_mode "middleware-only")}}
### 3.1 Middleware Components
List middleware to develop:
- **Middleware Name**: Purpose and behavior
- **Middleware Name**: Purpose and behavior

### 3.2 Execution Order
Define middleware execution order (critical):
1. CORS
2. Request ID generation
3. Logging (request start)
4. Authentication
5. Validation
6. Business logic handler
7. Logging (response)
8. Error handler

### 3.3 Testing Strategy
- How to test middleware in isolation?
- Mock handlers for testing
- Test cases for each middleware

### 3.4 Integration Points
- How middleware interacts with handlers
- Request/response transformation
- Context passing between middleware
{{else}}
### 3.1 Middleware Requirements
- Authentication middleware: (if needed)
- Validation middleware: (if needed)
- Custom middleware: (if needed)
- Refer to `infrastructure.md` for standard middleware patterns
{{/if}}

---

## 4. Verification Plan

### 4.1 Unit Tests
{{#unless (eq dev_mode "frontend-only")}}
- **Backend**: Test business logic, database operations
{{/unless}}
{{#unless (eq dev_mode "backend-only")}}
- **Frontend**: Test components, state management, API integration
{{/unless}}
{{#if (eq dev_mode "middleware-only")}}
- **Middleware**: Test each middleware in isolation
{{/if}}

### 4.2 Integration Tests
{{#if (eq dev_mode "fullstack")}}
- **E2E Tests**: What scenarios need coverage in Step 9?
- Test frontend + backend integration
- Verify contract compliance (request/response match `spec.md`)
{{/if}}
{{#if (eq dev_mode "backend-only")}}
- **API Tests**: Test endpoints with various inputs
- Verify response format matches `spec.md`
{{/if}}
{{#if (eq dev_mode "frontend-only")}}
- **Component Tests**: Test UI with mock data
- Verify data rendering and user interactions
{{/if}}

### 4.3 Contract Verification
- Verify API responses match `spec.md` JSON examples
- Check StandardResp structure compliance
- Validate error codes and messages
- Ensure pagination format is correct

---

## 5. Development Workflow

### 5.1 Phase 3: Frontend Mock Dev (Steps 6-7)
{{#unless (eq dev_mode "backend-only")}}
- Implement frontend with mock data
- Verify UI functionality locally
- No backend dependency required
{{else}}
- Skip (backend-only mode)
{{/unless}}

### 5.2 Phase 4: Backend Skeleton (Step 8)
{{#unless (eq dev_mode "frontend-only")}}
- Implement controller skeleton
- Return static JSON from `spec.md`
- NO database connection yet
{{else}}
- Skip (frontend-only mode)
{{/unless}}

### 5.3 Phase 5: Contract Testing (Step 9)
{{#if (eq dev_mode "fullstack")}}
- Run E2E tests against skeleton API
- Verify contract compliance
{{else}}
- Run appropriate tests for selected mode
{{/if}}

### 5.4 Phase 6: Implementation (Step 10)
{{#unless (eq dev_mode "frontend-only")}}
- Implement real database operations
- Replace mock data with real queries
- Implement business logic
{{/unless}}
{{#unless (eq dev_mode "backend-only")}}
- Connect frontend to real backend (if fullstack)
{{/unless}}

---

## 6. Infrastructure Integration

### 6.1 Logging
- Log all API requests with trace_id
- Log slow operations (>1s) with duration
- Log errors with full context
- Refer to `infrastructure.md` for logging format

### 6.2 Error Handling
- Use error codes from `infrastructure.md`
- Return StandardResp format for all errors
- Include error_details with trace_id
- Log errors before returning response

### 6.3 Request/Response Format
- All responses follow StandardResp structure
- Include X-Request-ID in request headers
- Pagination includes total_count
- Refer to `infrastructure.md` for format details

---

## 7. Notes

- This design is based on `spec.md` and `infrastructure.md`
- Development mode can be changed if requirements evolve
- All implementations must follow the 13-step workflow
- Infrastructure patterns are consistent across all features
